{
  "name": "wheel-picker",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "wheel-picker/WheelPicker.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends string | number\">\r\nimport { ref, computed, onMounted, onUnmounted, watch, nextTick, provide } from 'vue';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport interface WheelPickerOption<T = string | number> {\r\n  value: T;\r\n  label: string;\r\n}\r\n\r\nconst props = withDefaults(defineProps<{\r\n  modelValue?: T;\r\n  defaultValue?: T;\r\n  options?: WheelPickerOption<T>[];\r\n  infinite?: boolean;\r\n  visibleCount?: number;\r\n  dragSensitivity?: number;\r\n  scrollSensitivity?: number;\r\n  itemHeight?: number;\r\n  class?: string;\r\n}>(), {\r\n  options: () => [],\r\n  infinite: false,\r\n  visibleCount: 20,\r\n  dragSensitivity: 3,\r\n  scrollSensitivity: 5,\r\n  itemHeight: 30,\r\n});\r\n\r\nconst emit = defineEmits<{\r\n  (e: 'update:modelValue', value: T): void;\r\n}>();\r\n\r\n// --- 1. Option Gathering (Support for Props OR Children) ---\r\nconst childOptions = ref<WheelPickerOption<T>[]>([]);\r\nprovide('wheel-picker-register', (option: WheelPickerOption<T>) => {\r\n  childOptions.value.push(option);\r\n});\r\n\r\nconst optionsProp = computed(() => (props.options && props.options.length > 0) ? props.options : childOptions.value);\r\n\r\n// --- 2. Data Padding (React \"options\" useMemo Logic) ---\r\nconst options = computed(() => {\r\n  if (!props.infinite) return optionsProp.value;\r\n  \r\n  const result = [];\r\n  const halfCount = Math.ceil(props.visibleCount / 2);\r\n  \r\n  if (optionsProp.value.length === 0) return result;\r\n\r\n  // Clone options until we have enough to fill the half-circle\r\n  while (result.length < halfCount) {\r\n    result.push(...optionsProp.value);\r\n  }\r\n  return result;\r\n});\r\n\r\n// --- 3. Measurements ---\r\nconst measurements = computed(() => {\r\n  const count = props.visibleCount;\r\n  const height = props.itemHeight;\r\n  const itemAngle = 360 / count;\r\n  const radius = height / Math.tan((itemAngle * Math.PI) / 180);\r\n  const containerHeight = Math.round(radius * 2 + height * 0.25);\r\n  const quarterCount = count >> 2; \r\n\r\n  return { height, halfItemHeight: height * 0.5, itemAngle, radius, containerHeight, quarterCount };\r\n});\r\n\r\n// --- 4. Visual Padding (React \"renderWheelItems\" Logic) ---\r\nconst displayItems = computed(() => {\r\n  const { itemAngle, quarterCount } = measurements.value;\r\n  const src = options.value;\r\n  \r\n  // Base mapping\r\n  const items = src.map((item, index) => ({\r\n    ...item,\r\n    _index: index,\r\n    angle: -itemAngle * index\r\n  }));\r\n\r\n  if (props.infinite && src.length > 0) {\r\n    for (let i = 0; i < quarterCount; ++i) {\r\n      // Prepend\r\n      const prependIndex = -i - 1;\r\n      items.unshift({\r\n        ...src[src.length - i - 1], // Fixed index logic to match React\r\n        _index: prependIndex,\r\n        angle: itemAngle * (i + 1)\r\n      });\r\n      // Append\r\n      const appendIndex = i + src.length;\r\n      items.push({\r\n        ...src[i],\r\n        _index: appendIndex,\r\n        angle: -itemAngle * appendIndex\r\n      });\r\n    }\r\n  }\r\n  return items;\r\n});\r\n\r\nconst highlightItems = computed(() => {\r\n  const src = options.value;\r\n  const items = src.map((item, i) => ({ ...item, key: i }));\r\n  if (props.infinite && src.length > 0) {\r\n    items.unshift({ ...src[src.length - 1], key: 'start-inf' as any });\r\n    items.push({ ...src[0], key: 'end-inf' as any });\r\n  }\r\n  return items;\r\n});\r\n\r\nconst wheelSegmentPositions = computed(() => {\r\n  const { quarterCount, itemAngle, height } = measurements.value;\r\n  let pos = 0;\r\n  const segments: [number, number][] = [];\r\n  for (let i = quarterCount - 1; i >= -quarterCount + 1; --i) {\r\n    const len = height * Math.cos(i * itemAngle * (Math.PI / 180));\r\n    segments.push([pos, pos + len]);\r\n    pos += len;\r\n  }\r\n  return segments;\r\n});\r\n\r\n// --- 5. Physics State (Non-Reactive \"Refs\") ---\r\nconst containerRef = ref<HTMLElement | null>(null);\r\nconst wheelItemsRef = ref<HTMLElement | null>(null);\r\nconst highlightListRef = ref<HTMLElement | null>(null);\r\n\r\nconst localValue = ref<T>(props.modelValue ?? props.defaultValue ?? (optionsProp.value[0]?.value as T));\r\n\r\nlet scrollRef = 0;\r\nlet moveId = 0;\r\nlet isDragging = false;\r\nlet lastWheelTime = 0;\r\nlet dragController: AbortController | null = null;\r\n\r\nconst touchData = { \r\n  startY: 0, \r\n  yList: [] as [number, number][], \r\n  touchScroll: 0, \r\n  isClick: true \r\n};\r\n\r\n// --- 6. Core Logic (Exact Port) ---\r\nconst RESISTANCE = 0.3;\r\nconst MAX_VELOCITY = 30;\r\nconst easeOutCubic = (p: number) => Math.pow(p - 1, 3) + 1;\r\nconst clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(v, max));\r\n\r\nconst normalizeScroll = (scroll: number) => {\r\n  const len = options.value.length;\r\n  if (len === 0) return 0;\r\n  return ((scroll % len) + len) % len;\r\n};\r\n\r\nconst scrollTo = (scroll: number) => {\r\n  const { radius, itemAngle, quarterCount, height } = measurements.value;\r\n  const normalizedScroll = props.infinite ? normalizeScroll(scroll) : scroll;\r\n\r\n  // 3D Transform\r\n  if (wheelItemsRef.value) {\r\n    wheelItemsRef.value.style.transform = `translateZ(${-radius}px) rotateX(${itemAngle * normalizedScroll}deg)`;\r\n    \r\n    // Visibility Culling (Manual DOM access for speed)\r\n    const children = wheelItemsRef.value.children;\r\n    for (let i = 0; i < children.length; i++) {\r\n      const li = children[i] as HTMLElement;\r\n      const idx = parseFloat(li.dataset.index || '0');\r\n      const distance = Math.abs(idx - normalizedScroll);\r\n      li.style.visibility = distance > quarterCount ? \"hidden\" : \"visible\";\r\n    }\r\n  }\r\n\r\n  // Highlight Transform\r\n  if (highlightListRef.value) {\r\n    highlightListRef.value.style.transform = `translateY(${-normalizedScroll * height}px)`;\r\n  }\r\n\r\n  return normalizedScroll;\r\n};\r\n\r\nconst cancelAnimation = () => cancelAnimationFrame(moveId);\r\n\r\nconst animateScroll = (start: number, end: number, duration: number, onComplete?: () => void) => {\r\n  if (start === end || duration === 0) {\r\n    scrollTo(start);\r\n    return;\r\n  }\r\n  const startTime = performance.now();\r\n  const dist = end - start;\r\n  \r\n  const tick = (now: number) => {\r\n    const elapsed = (now - startTime) / 1000;\r\n    if (elapsed < duration) {\r\n      scrollRef = scrollTo(start + easeOutCubic(elapsed / duration) * dist);\r\n      moveId = requestAnimationFrame(tick);\r\n    } else {\r\n      cancelAnimation();\r\n      scrollRef = scrollTo(end);\r\n      onComplete?.();\r\n    }\r\n  };\r\n  requestAnimationFrame(tick);\r\n};\r\n\r\nconst selectByScroll = (scroll: number) => {\r\n  const opts = options.value;\r\n  if (!opts.length) return;\r\n  const norm = normalizeScroll(scroll) | 0;\r\n  const bounded = props.infinite ? norm : Math.min(Math.max(norm, 0), opts.length - 1);\r\n  \r\n  if (!props.infinite && bounded !== scroll) return;\r\n  \r\n  scrollRef = scrollTo(bounded);\r\n  const selected = opts[scrollRef];\r\n  if (selected && selected.value !== localValue.value) {\r\n    localValue.value = selected.value;\r\n    emit('update:modelValue', selected.value);\r\n  }\r\n};\r\n\r\nconst selectByValue = (val: T) => {\r\n  const idx = options.value.findIndex(o => o.value === val);\r\n  if (idx !== -1) {\r\n    cancelAnimation();\r\n    selectByScroll(idx);\r\n  }\r\n};\r\n\r\n// --- 7. Interactions (Drag/Touch) ---\r\nconst scrollByStep = (step: number) => {\r\n  const start = scrollRef;\r\n  let end = start + step;\r\n  if (props.infinite) end = Math.round(end);\r\n  else end = clamp(Math.round(end), 0, options.value.length - 1);\r\n  \r\n  const dist = Math.abs(end - start);\r\n  if (dist === 0) return;\r\n  \r\n  const duration = Math.sqrt(dist / props.scrollSensitivity);\r\n  cancelAnimation();\r\n  animateScroll(start, end, duration, () => selectByScroll(scrollRef));\r\n};\r\n\r\nconst updateScrollDuringDrag = (e: MouseEvent | TouchEvent) => {\r\n  const y = (e instanceof MouseEvent ? e.clientY : e.touches?.[0]?.clientY) || 0;\r\n  const { startY, yList } = touchData;\r\n  \r\n  if (touchData.isClick && Math.abs(y - startY) > 5) touchData.isClick = false;\r\n  \r\n  touchData.yList.push([y, Date.now()]);\r\n  if (touchData.yList.length > 5) touchData.yList.shift();\r\n  \r\n  const delta = (startY - y) / props.itemHeight;\r\n  let next = scrollRef + delta;\r\n  \r\n  if (props.infinite) {\r\n    next = normalizeScroll(next);\r\n  } else {\r\n    const max = options.value.length;\r\n    if (next < 0) next *= RESISTANCE;\r\n    else if (next > max) next = max + (next - max) * RESISTANCE;\r\n  }\r\n  \r\n  touchData.touchScroll = scrollTo(next);\r\n};\r\n\r\nconst handleDragStart = (e: MouseEvent | TouchEvent) => {\r\n  const isTarget = !!containerRef.value?.contains(e.target as Node) || e.target === containerRef.value;\r\n  if (!isTarget && !isDragging) return;\r\n  if (e.cancelable) e.preventDefault();\r\n\r\n  isDragging = true;\r\n  dragController = new AbortController();\r\n  const { signal } = dragController;\r\n  \r\n  const y = (e instanceof MouseEvent ? e.clientY : e.touches?.[0]?.clientY) || 0;\r\n  touchData.startY = y;\r\n  touchData.yList = [[y, Date.now()]];\r\n  touchData.touchScroll = scrollRef;\r\n  touchData.isClick = true;\r\n  \r\n  cancelAnimation();\r\n  \r\n  const opts = { signal, passive: false };\r\n  const onMove = (ev: MouseEvent | TouchEvent) => { if(ev.cancelable) ev.preventDefault(); updateScrollDuringDrag(ev); };\r\n  document.addEventListener('mousemove', onMove, opts);\r\n  document.addEventListener('touchmove', onMove, opts);\r\n  \r\n  const onEnd = (ev: MouseEvent | TouchEvent) => {\r\n    if(ev.cancelable) ev.preventDefault();\r\n    dragController?.abort();\r\n    dragController = null;\r\n    isDragging = false;\r\n    \r\n    if (touchData.isClick) {\r\n      handleWheelItemClick(touchData.startY);\r\n      return;\r\n    }\r\n    \r\n    // Inertia\r\n    let vel = 0;\r\n    const { yList } = touchData;\r\n    if (yList.length > 1) {\r\n      const last = yList[yList.length - 1];\r\n      const prev = yList[yList.length - 2];\r\n      const timeDiff = last[1] - prev[1];\r\n      if (timeDiff > 0) {\r\n        const dist = prev[0] - last[0];\r\n        const v = ((dist / props.itemHeight) * 1000) / timeDiff;\r\n        vel = Math.min(Math.abs(v), MAX_VELOCITY) * Math.sign(v);\r\n      }\r\n    }\r\n    \r\n    scrollRef = touchData.touchScroll;\r\n    decelerateAndAnimateScroll(vel);\r\n  };\r\n  \r\n  document.addEventListener('mouseup', onEnd, opts);\r\n  document.addEventListener('touchend', onEnd, opts);\r\n};\r\n\r\nconst handleWheelItemClick = (clientY: number) => {\r\n  if (!containerRef.value) return;\r\n  const { top } = containerRef.value.getBoundingClientRect();\r\n  const offset = clientY - top;\r\n  const idx = wheelSegmentPositions.value.findIndex(([s, e]) => offset >= s && offset <= e);\r\n  if (idx !== -1) {\r\n    const steps = (measurements.value.quarterCount - idx - 1) * -1;\r\n    scrollByStep(steps);\r\n  }\r\n};\r\n\r\nconst decelerateAndAnimateScroll = (velocity: number) => {\r\n  const start = scrollRef;\r\n  const len = options.value.length;\r\n  const decel = props.dragSensitivity * 10;\r\n  let end = start;\r\n  let duration = 0;\r\n  \r\n  if (props.infinite) {\r\n    duration = Math.abs(velocity / decel);\r\n    const dist = velocity * duration + 0.5 * (velocity > 0 ? -decel : decel) * duration ** 2;\r\n    end = Math.round(start + dist);\r\n  } else {\r\n    // Logic for boundary snapping\r\n    if (start < 0 || start > len - 1) {\r\n      end = clamp(start, 0, len - 1);\r\n      duration = Math.sqrt(Math.abs(start - end) / 10);\r\n    } else {\r\n      duration = Math.abs(velocity / decel);\r\n      const dist = velocity * duration + 0.5 * (velocity > 0 ? -decel : decel) * duration ** 2;\r\n      end = Math.round(start + dist);\r\n      end = clamp(end, 0, len - 1);\r\n      duration = Math.sqrt(Math.abs(end - start) / decel);\r\n    }\r\n  }\r\n  \r\n  animateScroll(start, end, duration, () => selectByScroll(scrollRef));\r\n};\r\n\r\nconst handleWheel = (e: WheelEvent) => {\r\n  if(!containerRef.value?.contains(e.target as Node)) return;\r\n  e.preventDefault();\r\n  if (Date.now() - lastWheelTime < 100) return;\r\n  lastWheelTime = Date.now();\r\n  scrollByStep(Math.sign(e.deltaY));\r\n};\r\n\r\nwatch(() => props.modelValue, (v) => { if(v !== undefined && v !== localValue.value) { localValue.value = v; selectByValue(v); }});\r\nonMounted(() => {\r\n  nextTick(() => selectByValue(localValue.value));\r\n  const el = containerRef.value;\r\n  if(el) {\r\n    el.addEventListener('mousedown', handleDragStart, { passive: false });\r\n    el.addEventListener('touchstart', handleDragStart, { passive: false });\r\n    el.addEventListener('wheel', handleWheel, { passive: false });\r\n  }\r\n});\r\nonUnmounted(() => {\r\n  const el = containerRef.value;\r\n  if(el) {\r\n    el.removeEventListener('mousedown', handleDragStart);\r\n    el.removeEventListener('touchstart', handleDragStart);\r\n    el.removeEventListener('wheel', handleWheel);\r\n  }\r\n});\r\n</script>\r\n\r\n<template>\r\n  <div ref=\"containerRef\" :class=\"cn($props.class)\" :style=\"{ height: `${measurements.containerHeight}px` }\" data-rwp>\r\n    \r\n    <slot />\r\n\r\n    <ul ref=\"wheelItemsRef\" data-rwp-options>\r\n      <li \r\n        v-for=\"item in displayItems\" \r\n        :key=\"`${item._index}-${item.value}`\"\r\n        :data-index=\"item._index\"\r\n        data-rwp-option\r\n        :style=\"{\r\n          top: `${-measurements.halfItemHeight}px`,\r\n          height: `${measurements.height}px`,\r\n          lineHeight: `${measurements.height}px`,\r\n          transform: `rotateX(${item.angle}deg) translateZ(${measurements.radius}px)`,\r\n          visibility: 'hidden'\r\n        }\"\r\n      >\r\n        {{ item.label }}\r\n      </li>\r\n    </ul>\r\n\r\n    <div \r\n      :class=\"cn(props.overlayClass)\" \r\n      data-rwp-highlight-wrapper\r\n      :style=\"{ height: `${measurements.height}px`, lineHeight: `${measurements.height}px` }\"\r\n    >\r\n      <ul ref=\"highlightListRef\" data-rwp-highlight-list :style=\"{ top: props.infinite ? `-${measurements.height}px` : undefined }\">\r\n        <li \r\n          v-for=\"item in highlightItems\" \r\n          :key=\"`${item.key}`\"\r\n          data-rwp-highlight-item\r\n          :style=\"{ height: `${measurements.height}px` }\"\r\n        >\r\n          {{ item.label }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n/* CSS copied exactly from React style.css */\r\n[data-rwp] {\r\n  position: relative;\r\n  overflow: hidden;\r\n  flex: 1;\r\n  cursor: default;\r\n  mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);\r\n  -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);\r\n}\r\n\r\n[data-rwp-highlight-wrapper] {\r\n  position: absolute;\r\n  overflow: hidden;\r\n  top: 50%;\r\n  width: 100%;\r\n  transform: translateY(-50%);\r\n  font-size: 1rem;\r\n  font-weight: 500;\r\n  pointer-events: none; /* crucial so clicks pass through to container */\r\n}\r\n\r\n[data-rwp-highlight-list] {\r\n  position: absolute;\r\n  width: 100%;\r\n}\r\n\r\n[data-rwp-options] {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 0;\r\n  display: block;\r\n  width: 100%;\r\n  height: 0;\r\n  margin: 0 auto;\r\n  -webkit-font-smoothing: subpixel-antialiased;\r\n  will-change: transform;\r\n  backface-visibility: hidden;\r\n  transform-style: preserve-3d;\r\n}\r\n\r\n[data-rwp-option] {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  -webkit-font-smoothing: subpixel-antialiased;\r\n  will-change: visibility;\r\n  font-size: 0.875rem;\r\n}\r\n\r\n[data-rwp-option], [data-rwp-highlight-item] {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/WheelPickerItem.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends string | number\">\r\nimport { inject, onMounted } from 'vue';\r\nimport type { WheelPickerOption } from './WheelPicker.vue';\r\n\r\nconst props = defineProps<{ value: T; label?: string; }>();\r\nconst register = inject<(option: WheelPickerOption<T>) => void>('wheel-picker-register');\r\n\r\nonMounted(() => {\r\n  if (register) register({ value: props.value, label: props.label ?? String(props.value) });\r\n});\r\n</script>\r\n<template><span style=\"display: none;\"></span></template>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/WheelPickerWrapper.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { cn } from '@/lib/utils';\r\n\r\ndefineProps<{\r\n  class?: string;\r\n}>();\r\n</script>\r\n\r\n<template>\r\n  <div :class=\"cn($props.class)\" data-rwp-wrapper>\r\n    <slot />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n/* Exact CSS from React source */\r\n[data-rwp-wrapper] {\r\n  position: relative;\r\n  overflow: hidden;\r\n  display: flex;\r\n  width: 100%;\r\n  align-items: stretch;\r\n  justify-content: space-between;\r\n  perspective: 2000px; /* <--- THIS FIXES THE VISUAL GLITCH */\r\n  user-select: none;\r\n}\r\n\r\n:deep([data-rwp-wrapper] ul) {\r\n  margin: 0;\r\n  padding: 0;\r\n  list-style: none;\r\n}\r\n\r\n:deep([data-rwp-wrapper] li) {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/index.ts",
      "content": "export { default as WheelPicker } from './WheelPicker.vue'\nexport { default as WheelPickerItem } from './WheelPickerItem.vue'\nexport { default as WheelPickerWrapper } from './WheelPickerWrapper.vue'\nexport type { WheelPickerOption } from './WheelPicker.vue'\n",
      "type": "registry:ui"
    }
  ]
}