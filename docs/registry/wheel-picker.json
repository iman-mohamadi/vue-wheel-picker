{
  "name": "wheel-picker",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "wheel-picker/WheelPicker.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends string | number\">\r\nimport { ref, computed, onMounted, onUnmounted, watch, nextTick, provide } from 'vue';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport interface WheelPickerOption<T = string | number> {\r\n  value: T;\r\n  label: string;\r\n}\r\n\r\nconst props = withDefaults(defineProps<{\r\n  modelValue?: T;\r\n  defaultValue?: T;\r\n  options?: WheelPickerOption<T>[];\r\n  infinite?: boolean;\r\n  visibleCount?: number;\r\n  dragSensitivity?: number;\r\n  scrollSensitivity?: number;\r\n  itemHeight?: number;\r\n  class?: string;\r\n  overlayClass?: string;\r\n}>(), {\r\n  options: () => [],\r\n  infinite: false,\r\n  visibleCount: 20,\r\n  dragSensitivity: 3,\r\n  scrollSensitivity: 5,\r\n  itemHeight: 30,\r\n});\r\n\r\nconst emit = defineEmits<{\r\n  (e: 'update:modelValue', value: T): void;\r\n}>();\r\n\r\n// --- Data Preparation ---\r\nconst childOptions = ref<WheelPickerOption<T>[]>([]);\r\nprovide('wheel-picker-register', (option: WheelPickerOption<T>) => {\r\n  childOptions.value.push(option);\r\n});\r\n\r\nconst activeOptions = computed(() => (props.options && props.options.length > 0) ? props.options : childOptions.value);\r\n\r\nconst paddedOptions = computed(() => {\r\n  if (!props.infinite) return activeOptions.value;\r\n  const result = [...activeOptions.value];\r\n  const halfCount = Math.ceil(props.visibleCount / 2);\r\n  while (result.length < halfCount && result.length > 0) {\r\n    result.push(...activeOptions.value);\r\n  }\r\n  return result;\r\n});\r\n\r\n// --- Measurements ---\r\nconst measurements = computed(() => {\r\n  const count = props.visibleCount;\r\n  const height = props.itemHeight;\r\n  const itemAngle = 360 / count;\r\n  const radius = height / Math.tan((itemAngle * Math.PI) / 180);\r\n  return { \r\n    height, \r\n    halfHeight: height * 0.5, \r\n    itemAngle, \r\n    radius, \r\n    containerHeight: Math.round(radius * 2 + height * 0.25), \r\n    quarterCount: count >> 2 \r\n  };\r\n});\r\n\r\n// --- Render Lists ---\r\n// 1. The 3D Wheel List\r\nconst wheelItems = computed(() => {\r\n  const { itemAngle, quarterCount } = measurements.value;\r\n  const opts = paddedOptions.value;\r\n  const items = opts.map((opt, i) => ({ ...opt, index: i, angle: -itemAngle * i }));\r\n  \r\n  if (props.infinite && opts.length > 0) {\r\n    for (let i = 0; i < quarterCount; ++i) {\r\n      items.unshift({ ...opts[opts.length - 1 - i], index: -i - 1, angle: itemAngle * (i + 1) });\r\n      items.push({ ...opts[i], index: i + opts.length, angle: -itemAngle * (i + opts.length) });\r\n    }\r\n  }\r\n  return items;\r\n});\r\n\r\n// 2. The Flat Highlight List\r\nconst highlightItems = computed(() => {\r\n  const opts = paddedOptions.value;\r\n  const items = opts.map((opt, i) => ({ ...opt, key: i }));\r\n  if (props.infinite && opts.length > 0) {\r\n    items.unshift({ ...opts[opts.length - 1], key: 'start-inf' as any });\r\n    items.push({ ...opts[0], key: 'end-inf' as any });\r\n  }\r\n  return items;\r\n});\r\n\r\nconst wheelSegmentPositions = computed(() => {\r\n  const { quarterCount, itemAngle, height } = measurements.value;\r\n  let pos = 0;\r\n  const segments: [number, number][] = [];\r\n  for (let i = quarterCount - 1; i >= -quarterCount + 1; --i) {\r\n    const len = height * Math.cos(i * itemAngle * (Math.PI / 180));\r\n    segments.push([pos, pos + len]);\r\n    pos += len;\r\n  }\r\n  return segments;\r\n});\r\n\r\n// --- Animation State (Non-Reactive) ---\r\nconst containerRef = ref<HTMLElement | null>(null);\r\nconst wheelRef = ref<HTMLElement | null>(null);\r\nconst hlRef = ref<HTMLElement | null>(null);\r\nconst localValue = ref<T>(props.modelValue ?? props.defaultValue ?? (activeOptions.value[0]?.value as T));\r\n\r\nlet scrollRef = 0;\r\nlet moveId = 0;\r\nlet isDragging = false;\r\nlet lastWheelTime = 0;\r\nlet dragController: AbortController | null = null;\r\nconst touchData = { startY: 0, yList: [] as [number, number][], touchScroll: 0, isClick: true };\r\n\r\n// --- Physics & Scroll ---\r\nconst RESISTANCE = 0.3;\r\nconst MAX_VELOCITY = 30;\r\nconst easeOutCubic = (p: number) => Math.pow(p - 1, 3) + 1;\r\nconst clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(v, max));\r\n\r\nconst normalize = (scroll: number) => {\r\n  const len = paddedOptions.value.length;\r\n  return len ? ((scroll % len) + len) % len : 0;\r\n};\r\n\r\nconst updateStyles = (scroll: number) => {\r\n  const { radius, itemAngle, quarterCount, height } = measurements.value;\r\n  const norm = props.infinite ? normalize(scroll) : scroll;\r\n\r\n  // Move 3D Container\r\n  if (wheelRef.value) {\r\n    wheelRef.value.style.transform = `translateZ(${-radius}px) rotateX(${itemAngle * norm}deg)`;\r\n    for (const child of wheelRef.value.children as any) {\r\n      const idx = Number(child.dataset.index);\r\n      const dist = Math.abs(idx - norm);\r\n      child.style.visibility = dist > quarterCount ? \"hidden\" : \"visible\";\r\n    }\r\n  }\r\n  // Move Highlight Container\r\n  if (hlRef.value) {\r\n    hlRef.value.style.transform = `translateY(${-norm * height}px)`;\r\n  }\r\n  return norm;\r\n};\r\n\r\nconst animate = (start: number, end: number, duration: number, done?: () => void) => {\r\n  if (start === end || duration === 0) {\r\n    updateStyles(start);\r\n    return;\r\n  }\r\n  const startTime = performance.now();\r\n  const dist = end - start;\r\n  const tick = (now: number) => {\r\n    const elapsed = (now - startTime) / 1000;\r\n    if (elapsed < duration) {\r\n      scrollRef = updateStyles(start + easeOutCubic(elapsed / duration) * dist);\r\n      moveId = requestAnimationFrame(tick);\r\n    } else {\r\n      scrollRef = updateStyles(end);\r\n      done?.();\r\n    }\r\n  };\r\n  requestAnimationFrame(tick);\r\n};\r\n\r\nconst selectByScroll = (scroll: number) => {\r\n  const opts = paddedOptions.value;\r\n  const norm = normalize(scroll) | 0;\r\n  const bounded = props.infinite ? norm : clamp(norm, 0, opts.length - 1);\r\n  \r\n  if (!props.infinite && bounded !== scroll) return;\r\n  \r\n  scrollRef = updateStyles(bounded);\r\n  const selected = opts[scrollRef];\r\n  if (selected && selected.value !== localValue.value) {\r\n    localValue.value = selected.value;\r\n    emit('update:modelValue', selected.value);\r\n  }\r\n};\r\n\r\nconst selectByValue = (val: T) => {\r\n  const idx = paddedOptions.value.findIndex(o => o.value === val);\r\n  if (idx !== -1) {\r\n    cancelAnimationFrame(moveId);\r\n    selectByScroll(idx);\r\n  }\r\n};\r\n\r\n// --- Interactions ---\r\nconst momentumScroll = (velocity: number) => {\r\n  const current = scrollRef;\r\n  const len = paddedOptions.value.length;\r\n  const decel = props.dragSensitivity * 10;\r\n  let target = current, duration = 0;\r\n\r\n  if (props.infinite) {\r\n    duration = Math.abs(velocity / decel);\r\n    target = Math.round(current + velocity * duration + 0.5 * (velocity > 0 ? -decel : decel) * duration ** 2);\r\n  } else {\r\n    // Bounds logic\r\n    if (current < 0 || current > len - 1) {\r\n      target = clamp(current, 0, len - 1);\r\n      duration = Math.sqrt(Math.abs((current - target) / 10)); // Snap back\r\n    } else {\r\n      duration = Math.abs(velocity / decel);\r\n      target = clamp(Math.round(current + velocity * duration + 0.5 * (velocity > 0 ? -decel : decel) * duration ** 2), 0, len - 1);\r\n      duration = Math.sqrt(Math.abs((target - current) / decel));\r\n    }\r\n  }\r\n  animate(current, target, duration, () => selectByScroll(scrollRef));\r\n};\r\n\r\nconst handleDrag = (e: MouseEvent | TouchEvent) => {\r\n  if (!containerRef.value?.contains(e.target as Node)) return;\r\n  e.preventDefault();\r\n  isDragging = true;\r\n  touchData.startY = (e instanceof MouseEvent ? e.clientY : e.touches[0].clientY);\r\n  touchData.yList = [[touchData.startY, Date.now()]];\r\n  touchData.touchScroll = scrollRef;\r\n  touchData.isClick = true;\r\n  cancelAnimationFrame(moveId);\r\n\r\n  const move = (ev: MouseEvent | TouchEvent) => {\r\n    ev.preventDefault();\r\n    const y = (ev instanceof MouseEvent ? ev.clientY : ev.touches[0].clientY);\r\n    if (Math.abs(y - touchData.startY) > 5) touchData.isClick = false;\r\n    touchData.yList.push([y, Date.now()]);\r\n    \r\n    const delta = (touchData.startY - y) / props.itemHeight;\r\n    let next = scrollRef + delta;\r\n    if (props.infinite) next = normalize(next);\r\n    else if (next < 0 || next > paddedOptions.value.length) next -= (next - (next < 0 ? 0 : paddedOptions.value.length)) * (1 - RESISTANCE);\r\n    \r\n    touchData.touchScroll = updateStyles(next);\r\n  };\r\n\r\n  const end = () => {\r\n    isDragging = false;\r\n    document.removeEventListener('mousemove', move);\r\n    document.removeEventListener('mouseup', end);\r\n    document.removeEventListener('touchmove', move);\r\n    document.removeEventListener('touchend', end);\r\n\r\n    if (touchData.isClick) {\r\n      const { top } = containerRef.value!.getBoundingClientRect();\r\n      const idx = wheelSegmentPositions.value.findIndex(([s, e]) => touchData.startY - top >= s && touchData.startY - top <= e);\r\n      if (idx !== -1) {\r\n        const step = (measurements.value.quarterCount - idx - 1) * -1;\r\n        const target = scrollRef + step;\r\n        animate(scrollRef, props.infinite ? Math.round(target) : clamp(Math.round(target), 0, paddedOptions.value.length - 1), Math.sqrt(Math.abs(step) / props.scrollSensitivity), () => selectByScroll(scrollRef));\r\n      }\r\n      return;\r\n    }\r\n\r\n    const last = touchData.yList[touchData.yList.length - 1];\r\n    const prev = touchData.yList[touchData.yList.length - 2];\r\n    let vel = 0;\r\n    if (last && prev && (last[1] - prev[1]) > 0) {\r\n      vel = ((prev[0] - last[0]) / props.itemHeight * 1000) / (last[1] - prev[1]);\r\n      vel = Math.sign(vel) * Math.min(Math.abs(vel), MAX_VELOCITY);\r\n    }\r\n    scrollRef = touchData.touchScroll;\r\n    momentumScroll(vel);\r\n  };\r\n\r\n  document.addEventListener('mousemove', move, { passive: false });\r\n  document.addEventListener('mouseup', end);\r\n  document.addEventListener('touchmove', move, { passive: false });\r\n  document.addEventListener('touchend', end);\r\n};\r\n\r\nconst handleWheel = (e: WheelEvent) => {\r\n  if (!containerRef.value?.contains(e.target as Node)) return;\r\n  e.preventDefault();\r\n  if (Date.now() - lastWheelTime < 100) return;\r\n  lastWheelTime = Date.now();\r\n  const step = Math.sign(e.deltaY);\r\n  const target = scrollRef + step;\r\n  animate(scrollRef, props.infinite ? Math.round(target) : clamp(Math.round(target), 0, paddedOptions.value.length - 1), Math.sqrt(1 / props.scrollSensitivity), () => selectByScroll(scrollRef));\r\n};\r\n\r\nwatch(() => props.modelValue, (v) => v !== undefined && v !== localValue.value && (localValue.value = v, selectByValue(v)));\r\nonMounted(() => {\r\n  nextTick(() => selectByValue(localValue.value));\r\n  containerRef.value?.addEventListener('mousedown', handleDrag);\r\n  containerRef.value?.addEventListener('touchstart', handleDrag, { passive: false });\r\n  containerRef.value?.addEventListener('wheel', handleWheel, { passive: false });\r\n});\r\nonUnmounted(() => {\r\n  containerRef.value?.removeEventListener('mousedown', handleDrag);\r\n  containerRef.value?.removeEventListener('touchstart', handleDrag);\r\n  containerRef.value?.removeEventListener('wheel', handleWheel);\r\n});\r\n</script>\r\n\r\n<template>\r\n  <div ref=\"containerRef\" :class=\"cn('wheel-picker', $props.class)\" :style=\"{ height: `${measurements.containerHeight}px` }\">\r\n    <slot />\r\n    \r\n    <div class=\"wheel-scroller\">\r\n      <ul ref=\"wheelRef\" class=\"wheel-list\">\r\n        <li v-for=\"item in wheelItems\" :key=\"`${item.index}`\" :data-index=\"item.index\" class=\"wheel-item\"\r\n          :style=\"{ top: `${-measurements.halfHeight}px`, height: `${measurements.height}px`, transform: `rotateX(${item.angle}deg) translateZ(${measurements.radius}px)` }\">\r\n          {{ item.label }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n\r\n    <div :class=\"cn('wheel-overlay', props.overlayClass)\" :style=\"{ height: `${measurements.height}px` }\">\r\n      <ul ref=\"hlRef\" class=\"wheel-list highlight-list\" :style=\"{ top: props.infinite ? `-${measurements.height}px` : undefined }\">\r\n        <li v-for=\"item in highlightItems\" :key=\"`${item.key}`\" class=\"wheel-item\" :style=\"{ height: `${measurements.height}px` }\">\r\n          {{ item.label }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.wheel-picker {\r\n  position: relative;\r\n  overflow: hidden;\r\n  flex: 1;\r\n  cursor: default;\r\n  mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);\r\n  -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);\r\n}\r\n\r\n.wheel-scroller {\r\n  position: relative;\r\n  height: 100%;\r\n  overflow: hidden;\r\n}\r\n\r\n.wheel-list {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 0;\r\n  width: 100%;\r\n  margin: 0;\r\n  padding: 0;\r\n  list-style: none;\r\n  transform-style: preserve-3d;\r\n  will-change: transform;\r\n}\r\n\r\n.wheel-item {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  backface-visibility: hidden;\r\n  font-size: 0.875rem;\r\n}\r\n\r\n.wheel-overlay {\r\n  position: absolute;\r\n  top: 50%;\r\n  width: 100%;\r\n  transform: translateY(-50%);\r\n  pointer-events: none;\r\n  border-top: 1px solid hsl(var(--border));\r\n  border-bottom: 1px solid hsl(var(--border));\r\n  background: hsl(var(--background) / 0.1);\r\n}\r\n\r\n.highlight-list .wheel-item {\r\n  position: relative;\r\n  font-weight: 500;\r\n  color: hsl(var(--foreground));\r\n}\r\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/WheelPickerItem.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends string | number\">\r\nimport { inject, onMounted } from 'vue';\r\nimport type { WheelPickerOption } from './WheelPicker.vue';\r\n\r\nconst props = defineProps<{\r\n  value: T;\r\n  label?: string; \r\n}>();\r\n\r\n// Inject the register function from parent\r\nconst register = inject<(option: WheelPickerOption<T>) => void>('wheel-picker-register');\r\n\r\nonMounted(() => {\r\n  if (register) {\r\n    register({\r\n      value: props.value,\r\n      label: props.label ?? String(props.value), \r\n    });\r\n  }\r\n});\r\n</script>\r\n\r\n<template>\r\n  <span style=\"display: none;\"></span>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/WheelPickerWrapper.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { cn } from '@/lib/utils'\r\n\r\ndefineProps<{\r\n  class?: string\r\n}>()\r\n</script>\r\n\r\n<template>\r\n  <div :class=\"cn('wheel-picker-wrapper', $props.class)\">\r\n    <slot />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.wheel-picker-wrapper {\r\n  position: relative;\r\n  overflow: hidden;\r\n  display: flex;\r\n  width: 100%;\r\n  align-items: stretch;\r\n  justify-content: space-between;\r\n  perspective: 2000px;\r\n  user-select: none;\r\n}\r\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/index.ts",
      "content": "export { default as WheelPicker } from './WheelPicker.vue'\nexport { default as WheelPickerItem } from './WheelPickerItem.vue'\nexport { default as WheelPickerWrapper } from './WheelPickerWrapper.vue'\nexport type { WheelPickerOption } from './WheelPicker.vue'\n",
      "type": "registry:ui"
    }
  ]
}