{
  "name": "wheel-picker",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "wheel-picker/index.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends string | number\">\r\nimport { ref, computed, onMounted, onUnmounted, watch, nextTick, type CSSProperties } from 'vue';\r\nimport { cn } from '@/lib/utils';\r\nimport type { WheelPickerOption } from './types';\r\n\r\nconst props = withDefaults(defineProps<{\r\n  modelValue?: T;\r\n  defaultValue?: T;\r\n  options?: WheelPickerOption<T>[];\r\n  infinite?: boolean;\r\n  visibleCount?: number;\r\n  dragSensitivity?: number;\r\n  scrollSensitivity?: number;\r\n  itemHeight?: number;\r\n  class?: string;\r\n  overlayClass?: string;\r\n}>(), {\r\n  options: () => [],\r\n  infinite: false,\r\n  visibleCount: 20,\r\n  dragSensitivity: 3,\r\n  scrollSensitivity: 5,\r\n  itemHeight: 30,\r\n});\r\n\r\nconst emit = defineEmits<{\r\n  (e: 'update:modelValue', value: T): void;\r\n}>();\r\n\r\n// --- Constants & Utils ---\r\nconst RESISTANCE = 0.3;\r\nconst MAX_VELOCITY = 30;\r\nconst easeOutCubic = (p: number) => Math.pow(p - 1, 3) + 1;\r\nconst clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(value, max));\r\n\r\n// --- State ---\r\nconst containerRef = ref<HTMLElement | null>(null);\r\nconst wheelItemsRef = ref<HTMLElement | null>(null);\r\nconst highlightListRef = ref<HTMLElement | null>(null);\r\n\r\n// Internal state for v-model handling\r\nconst localValue = ref<T>(props.modelValue ?? props.defaultValue ?? props.options[0]?.value);\r\n\r\n// Physics state (non-reactive for performance loop)\r\nlet scrollPos = 0;\r\nlet isDragging = false;\r\nlet moveId = 0;\r\nlet lastWheelTime = 0;\r\nlet dragController: AbortController | null = null;\r\n\r\nconst touchData = {\r\n  startY: 0,\r\n  yList: [] as [number, number][],\r\n  touchScroll: 0,\r\n  isClick: true,\r\n};\r\n\r\n// --- Computed Props ---\r\nconst processedOptions = computed(() => {\r\n  if (!props.infinite || props.options.length === 0) return props.options;\r\n  \r\n  const result: WheelPickerOption<T>[] = [];\r\n  const halfCount = Math.ceil(props.visibleCount / 2);\r\n  while (result.length < halfCount) {\r\n    result.push(...props.options);\r\n  }\r\n  return result;\r\n});\r\n\r\nconst measurements = computed(() => {\r\n  const count = props.visibleCount;\r\n  const height = props.itemHeight;\r\n  const halfItemHeight = height * 0.5;\r\n  const itemAngle = 360 / count;\r\n  const radius = height / Math.tan((itemAngle * Math.PI) / 180);\r\n  const containerHeight = Math.round(radius * 2 + height * 0.25);\r\n  const quarterCount = count >> 2;\r\n\r\n  return { height, halfItemHeight, itemAngle, radius, containerHeight, quarterCount };\r\n});\r\n\r\nconst displayItems = computed(() => {\r\n  const { itemAngle, quarterCount } = measurements.value;\r\n  const opts = processedOptions.value;\r\n  \r\n  const items = opts.map((option, index) => ({\r\n    ...option,\r\n    index,\r\n    angle: -itemAngle * index\r\n  }));\r\n\r\n  if (props.infinite && props.options.length > 0) {\r\n    for (let i = 0; i < quarterCount; ++i) {\r\n      // Prepend\r\n      items.unshift({\r\n        ...opts[opts.length - 1 - i],\r\n        index: -i - 1,\r\n        angle: itemAngle * (i + 1)\r\n      });\r\n      // Append\r\n      items.push({\r\n        ...opts[i],\r\n        index: i + opts.length,\r\n        angle: -itemAngle * (i + opts.length)\r\n      });\r\n    }\r\n  }\r\n  return items;\r\n});\r\n\r\nconst highlightItems = computed(() => {\r\n  const opts = processedOptions.value;\r\n  const items = opts.map((opt, i) => ({ ...opt, key: i }));\r\n  \r\n  if (props.infinite && opts.length > 0) {\r\n    items.unshift({ ...opts[opts.length - 1], key: 'start-inf' as any });\r\n    items.push({ ...opts[0], key: 'end-inf' as any });\r\n  }\r\n  return items;\r\n});\r\n\r\nconst wheelSegmentPositions = computed(() => {\r\n  const { quarterCount, itemAngle, height } = measurements.value;\r\n  let positionAlongWheel = 0;\r\n  const degToRad = Math.PI / 180;\r\n  const segments: [number, number][] = [];\r\n\r\n  for (let i = quarterCount - 1; i >= -quarterCount + 1; --i) {\r\n    const angle = i * itemAngle;\r\n    const segmentLength = height * Math.cos(angle * degToRad);\r\n    const start = positionAlongWheel;\r\n    positionAlongWheel += segmentLength;\r\n    segments.push([start, positionAlongWheel]);\r\n  }\r\n  return segments;\r\n});\r\n\r\n// --- Core Logic ---\r\n\r\nconst normalizeScroll = (scroll: number) => {\r\n  const len = processedOptions.value.length;\r\n  if(len === 0) return 0;\r\n  return ((scroll % len) + len) % len;\r\n};\r\n\r\nconst updateStyles = (scroll: number) => {\r\n  const { radius, itemAngle, quarterCount, height } = measurements.value;\r\n  const normalizedScroll = props.infinite ? normalizeScroll(scroll) : scroll;\r\n\r\n  // 1. Rotate the 3D Wheel\r\n  if (wheelItemsRef.value) {\r\n    const transform = `translateZ(${-radius}px) rotateX(${itemAngle * normalizedScroll}deg)`;\r\n    wheelItemsRef.value.style.transform = transform;\r\n\r\n    // Visibility culling for performance\r\n    const childNodes = wheelItemsRef.value.children;\r\n    for (let i = 0; i < childNodes.length; i++) {\r\n      const li = childNodes[i] as HTMLElement;\r\n      const idx = Number(li.dataset.index);\r\n      const distance = Math.abs(idx - normalizedScroll);\r\n      li.style.visibility = distance > quarterCount ? \"hidden\" : \"visible\";\r\n    }\r\n  }\r\n\r\n  // 2. Move the Flat Highlight List\r\n  if (highlightListRef.value) {\r\n    highlightListRef.value.style.transform = `translateY(${-normalizedScroll * height}px)`;\r\n  }\r\n\r\n  return normalizedScroll;\r\n};\r\n\r\nconst cancelAnimation = () => cancelAnimationFrame(moveId);\r\n\r\nconst selectByScroll = (scroll: number) => {\r\n  const opts = processedOptions.value;\r\n  if(!opts.length) return;\r\n\r\n  const normalized = normalizeScroll(scroll) | 0;\r\n  const boundedScroll = props.infinite \r\n    ? normalized \r\n    : Math.min(Math.max(normalized, 0), opts.length - 1);\r\n\r\n  if (!props.infinite && boundedScroll !== scroll) return;\r\n  \r\n  scrollPos = updateStyles(boundedScroll);\r\n  \r\n  // Update Value\r\n  const selected = opts[scrollPos];\r\n  if(selected && selected.value !== localValue.value) {\r\n    localValue.value = selected.value;\r\n    emit('update:modelValue', selected.value);\r\n  }\r\n};\r\n\r\nconst animateScroll = (startScroll: number, endScroll: number, duration: number, onComplete?: () => void) => {\r\n  if (startScroll === endScroll || duration === 0) {\r\n    updateStyles(startScroll);\r\n    return;\r\n  }\r\n\r\n  const startTime = performance.now();\r\n  const totalDistance = endScroll - startScroll;\r\n\r\n  const tick = (currentTime: number) => {\r\n    const elapsed = (currentTime - startTime) / 1000;\r\n    if (elapsed < duration) {\r\n      const progress = easeOutCubic(elapsed / duration);\r\n      scrollPos = updateStyles(startScroll + progress * totalDistance);\r\n      moveId = requestAnimationFrame(tick);\r\n    } else {\r\n      cancelAnimation();\r\n      scrollPos = updateStyles(endScroll);\r\n      onComplete?.();\r\n    }\r\n  };\r\n  requestAnimationFrame(tick);\r\n};\r\n\r\nconst selectByValue = (val: T) => {\r\n  const index = processedOptions.value.findIndex(o => o.value === val);\r\n  if (index === -1) return;\r\n  cancelAnimation();\r\n  selectByScroll(index);\r\n};\r\n\r\n// --- Interactions ---\r\n\r\nconst scrollByStep = (step: number) => {\r\n  const startScroll = scrollPos;\r\n  let endScroll = startScroll + step;\r\n  const len = processedOptions.value.length;\r\n\r\n  if (props.infinite) {\r\n    endScroll = Math.round(endScroll);\r\n  } else {\r\n    endScroll = clamp(Math.round(endScroll), 0, len - 1);\r\n  }\r\n\r\n  const distance = Math.abs(endScroll - startScroll);\r\n  if (distance === 0) return;\r\n\r\n  const duration = Math.sqrt(distance / props.scrollSensitivity);\r\n  cancelAnimation();\r\n  animateScroll(startScroll, endScroll, duration, () => {\r\n    selectByScroll(scrollPos);\r\n  });\r\n};\r\n\r\nconst handleWheel = (e: WheelEvent) => {\r\n  if (isDragging || !processedOptions.value.length) return;\r\n  \r\n  // Check if target is inside container\r\n  if(!containerRef.value?.contains(e.target as Node)) return;\r\n\r\n  e.preventDefault();\r\n  const now = Date.now();\r\n  if (now - lastWheelTime < 100) return;\r\n  \r\n  const direction = Math.sign(e.deltaY);\r\n  if (!direction) return;\r\n  \r\n  lastWheelTime = now;\r\n  scrollByStep(direction);\r\n};\r\n\r\n// --- Drag / Touch Logic ---\r\n\r\nconst decelerateAndAnimateScroll = (initialVelocity: number) => {\r\n  const currentScroll = scrollPos;\r\n  const len = processedOptions.value.length;\r\n  const baseDeceleration = props.dragSensitivity * 10;\r\n  \r\n  let targetScroll = currentScroll;\r\n  let deceleration = initialVelocity > 0 ? -baseDeceleration : baseDeceleration;\r\n  let duration = 0;\r\n\r\n  if (props.infinite) {\r\n    duration = Math.abs(initialVelocity / deceleration);\r\n    const dist = initialVelocity * duration + 0.5 * deceleration * duration * duration;\r\n    targetScroll = Math.round(currentScroll + dist);\r\n  } else if (currentScroll < 0 || currentScroll > len - 1) {\r\n    const target = clamp(currentScroll, 0, len - 1);\r\n    const dist = currentScroll - target;\r\n    const snapDecel = 10; // Snap back deceleration\r\n    duration = Math.sqrt(Math.abs(dist / snapDecel));\r\n    // Provide a small push to animate back\r\n    initialVelocity = snapDecel * duration;\r\n    initialVelocity = currentScroll > 0 ? -initialVelocity : initialVelocity;\r\n    targetScroll = target;\r\n  } else {\r\n    duration = Math.abs(initialVelocity / deceleration);\r\n    const dist = initialVelocity * duration + 0.5 * deceleration * duration * duration;\r\n    targetScroll = Math.round(currentScroll + dist);\r\n    targetScroll = clamp(targetScroll, 0, len - 1);\r\n    \r\n    // Recalculate duration for clamped target\r\n    const adjDist = targetScroll - currentScroll;\r\n    duration = Math.sqrt(Math.abs(adjDist / deceleration));\r\n  }\r\n\r\n  animateScroll(currentScroll, targetScroll, duration, () => selectByScroll(scrollPos));\r\n  // Fallback\r\n  selectByScroll(scrollPos); \r\n};\r\n\r\nconst updateScrollDuringDrag = (e: MouseEvent | TouchEvent) => {\r\n  const currentY = (e instanceof MouseEvent ? e.clientY : e.touches?.[0]?.clientY) || 0;\r\n  const { startY, yList } = touchData;\r\n\r\n  if (touchData.isClick && Math.abs(currentY - startY) > 5) {\r\n    touchData.isClick = false;\r\n  }\r\n\r\n  touchData.yList.push([currentY, Date.now()]);\r\n  if (touchData.yList.length > 5) touchData.yList.shift();\r\n\r\n  const dragDelta = (startY - currentY) / props.itemHeight;\r\n  let nextScroll = scrollPos + dragDelta;\r\n  const len = processedOptions.value.length;\r\n\r\n  if (props.infinite) {\r\n    nextScroll = normalizeScroll(nextScroll);\r\n  } else {\r\n    if (nextScroll < 0) nextScroll *= RESISTANCE;\r\n    else if (nextScroll > len) nextScroll = len + (nextScroll - len) * RESISTANCE;\r\n  }\r\n  \r\n  touchData.touchScroll = updateStyles(nextScroll);\r\n};\r\n\r\nconst handleDragStart = (e: MouseEvent | TouchEvent) => {\r\n  if(!containerRef.value?.contains(e.target as Node)) return;\r\n  e.preventDefault();\r\n\r\n  isDragging = true;\r\n  dragController = new AbortController();\r\n  const { signal } = dragController;\r\n  \r\n  const startY = (e instanceof MouseEvent ? e.clientY : e.touches?.[0]?.clientY) || 0;\r\n  \r\n  touchData.startY = startY;\r\n  touchData.yList = [[startY, Date.now()]];\r\n  touchData.touchScroll = scrollPos;\r\n  touchData.isClick = true;\r\n\r\n  cancelAnimation();\r\n\r\n  // Attach global listeners\r\n  const opts = { signal, passive: false };\r\n  document.addEventListener(\"mousemove\", (ev) => updateScrollDuringDrag(ev), opts);\r\n  document.addEventListener(\"touchmove\", (ev) => updateScrollDuringDrag(ev), opts);\r\n  \r\n  const handleEnd = (ev: MouseEvent | TouchEvent) => {\r\n    ev.preventDefault();\r\n    dragController?.abort();\r\n    dragController = null;\r\n    isDragging = false;\r\n\r\n    // Handle Click\r\n    if (touchData.isClick) {\r\n      const { top } = containerRef.value!.getBoundingClientRect();\r\n      const clickOffsetY = touchData.startY - top;\r\n      \r\n      const idx = wheelSegmentPositions.value.findIndex(([start, end]) => \r\n        clickOffsetY >= start && clickOffsetY <= end\r\n      );\r\n      \r\n      if (idx !== -1) {\r\n        const steps = (measurements.value.quarterCount - idx - 1) * -1;\r\n        scrollByStep(steps);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle Inertia\r\n    let velocity = 0;\r\n    const { yList } = touchData;\r\n    if (yList.length > 1) {\r\n      const [endY, endTime] = yList[yList.length - 1];\r\n      const [startY, startTime] = yList[yList.length - 2];\r\n      const timeDiff = endTime - startTime;\r\n      \r\n      if (timeDiff > 0) {\r\n        const dist = startY - endY;\r\n        const velPerSec = ((dist / props.itemHeight) * 1000) / timeDiff;\r\n        velocity = Math.min(Math.abs(velPerSec), MAX_VELOCITY) * (velPerSec > 0 ? 1 : -1);\r\n      }\r\n    }\r\n    \r\n    scrollPos = touchData.touchScroll;\r\n    decelerateAndAnimateScroll(velocity);\r\n  };\r\n\r\n  document.addEventListener(\"mouseup\", handleEnd, opts);\r\n  document.addEventListener(\"touchend\", handleEnd, opts);\r\n};\r\n\r\n// --- Lifecycle & Watchers ---\r\n\r\nwatch(() => props.modelValue, (newVal) => {\r\n  if (newVal !== undefined && newVal !== localValue.value) {\r\n    localValue.value = newVal;\r\n    selectByValue(newVal);\r\n  }\r\n});\r\n\r\nonMounted(() => {\r\n  const container = containerRef.value;\r\n  if (!container) return;\r\n  \r\n  // Initial draw\r\n  nextTick(() => {\r\n    selectByValue(localValue.value);\r\n  });\r\n\r\n  // Events\r\n  container.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n  container.addEventListener(\"mousedown\", handleDragStart, { passive: false });\r\n  container.addEventListener(\"touchstart\", handleDragStart, { passive: false });\r\n});\r\n\r\nonUnmounted(() => {\r\n  const container = containerRef.value;\r\n  if (container) {\r\n    container.removeEventListener(\"wheel\", handleWheel);\r\n    container.removeEventListener(\"mousedown\", handleDragStart);\r\n    container.removeEventListener(\"touchstart\", handleDragStart);\r\n  }\r\n});\r\n</script>\r\n\r\n<template>\r\n  <div \r\n    ref=\"containerRef\" \r\n    :class=\"cn('relative flex w-full overflow-hidden select-none items-stretch justify-between', $props.class)\" \r\n    class=\"wheel-picker-root\"\r\n    :style=\"{ height: `${measurements.containerHeight}px`, perspective: '2000px' }\"\r\n  >\r\n    <div class=\"relative flex-1 overflow-hidden cursor-default mask-gradient\">\r\n      <ul ref=\"wheelItemsRef\" class=\"wheel-3d-list\">\r\n        <li \r\n          v-for=\"(item) in displayItems\" \r\n          :key=\"`${item.index}-${item.value}`\"\r\n          :data-index=\"item.index\"\r\n          class=\"absolute left-0 top-0 flex w-full items-center justify-center text-sm text-muted-foreground will-change-[transform,visibility]\"\r\n          :style=\"{\r\n            top: `${-measurements.halfItemHeight}px`,\r\n            height: `${measurements.height}px`,\r\n            lineHeight: `${measurements.height}px`,\r\n            transform: `rotateX(${item.angle}deg) translateZ(${measurements.radius}px)`,\r\n          }\"\r\n        >\r\n          {{ item.label }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n\r\n    <div \r\n      :class=\"cn('absolute top-1/2 w-full -translate-y-1/2 overflow-hidden text-base font-medium text-foreground pointer-events-none', props.overlayClass)\"\r\n      :style=\"{ height: `${measurements.height}px`, lineHeight: `${measurements.height}px` }\"\r\n    >\r\n      <ul ref=\"highlightListRef\" class=\"absolute w-full\" :style=\"{ top: props.infinite ? `-${measurements.height}px` : undefined }\">\r\n        <li \r\n          v-for=\"item in highlightItems\" \r\n          :key=\"`${item.key}`\"\r\n          class=\"flex items-center justify-center\"\r\n          :style=\"{ height: `${measurements.height}px` }\"\r\n        >\r\n          {{ item.label }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.wheel-picker-root {\r\n  /* Ensure mask works in various browsers */\r\n  mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);\r\n  -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);\r\n}\r\n\r\n.wheel-3d-list {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 0;\r\n  display: block;\r\n  width: 100%;\r\n  height: 0;\r\n  margin: 0 auto;\r\n  transform-style: preserve-3d;\r\n}\r\n</style>",
      "type": "registry:ui"
    }
  ]
}